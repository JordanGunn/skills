#!/usr/bin/env python3
"""
task_hash.py - Compute and update intent hash for a task.

Computes SHA256 hash from canonical intent blob and updates 00_TASK.md frontmatter.
Optionally writes hash record to 99_STATE.md.

Usage:
    python task_hash.py --task /path/to/task-dir
    python task_hash.py --task /path/to/task-dir --update
    python task_hash.py --task /path/to/task-dir --check

Options:
    --update    Update 00_TASK.md frontmatter with computed hash
    --check     Check if stored hash matches computed hash (exit 0 if match, 1 if mismatch)
    --state     Also write hash record to 99_STATE.md
"""

import argparse
import hashlib
import json
import re
import sys
from datetime import datetime, timezone
from pathlib import Path


def get_utc_now_rfc3339() -> str:
    """Return current UTC time in RFC3339 format."""
    return datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")


def compute_hash(canonical_blob: str) -> str:
    """Compute SHA256 hash of canonical intent blob."""
    return hashlib.sha256(canonical_blob.encode("utf-8")).hexdigest()


def extract_canonical_intent(task_dir: Path) -> str:
    """Extract canonical intent blob (delegating to task_intent_extract logic)."""
    import importlib.util
    
    script_dir = Path(__file__).parent
    extract_script = script_dir / "task_intent_extract.py"
    
    if extract_script.exists():
        spec = importlib.util.spec_from_file_location("task_intent_extract", extract_script)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module.extract_canonical_intent(task_dir)
    else:
        raise ImportError("task_intent_extract.py not found in script directory")


def read_frontmatter(task_file: Path) -> tuple[dict, str, str]:
    """Read frontmatter and body from task file. Returns (frontmatter_dict, frontmatter_raw, body)."""
    content = task_file.read_text(encoding="utf-8")
    
    if not content.startswith("---"):
        raise ValueError("Missing frontmatter delimiter")
    
    parts = content.split("---", 2)
    if len(parts) < 3:
        raise ValueError("Missing closing frontmatter delimiter")
    
    frontmatter_raw = parts[1]
    body = parts[2]
    
    try:
        import yaml
        frontmatter = yaml.safe_load(frontmatter_raw.strip())
    except ImportError:
        frontmatter = _parse_simple_yaml(frontmatter_raw.strip())
    
    return frontmatter, frontmatter_raw, body


def _parse_simple_yaml(raw: str) -> dict:
    """Simple YAML parser fallback."""
    result = {}
    for line in raw.split("\n"):
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if ":" in line:
            key, _, value = line.partition(":")
            result[key.strip()] = value.strip().strip('"').strip("'")
    return result


def update_frontmatter_hash(task_file: Path, new_hash: str) -> None:
    """Update intent_hash in frontmatter."""
    content = task_file.read_text(encoding="utf-8")
    
    hash_pattern = r'(intent_hash:\s*)["\']?[a-f0-9]{64}["\']?'
    placeholder_pattern = r'(intent_hash:\s*)["\']?\{\{INTENT_HASH\}\}["\']?'
    
    if re.search(hash_pattern, content):
        content = re.sub(hash_pattern, f'\\1"{new_hash}"', content)
    elif re.search(placeholder_pattern, content):
        content = re.sub(placeholder_pattern, f'\\1"{new_hash}"', content)
    else:
        parts = content.split("---", 2)
        if len(parts) >= 3:
            fm_lines = parts[1].strip().split("\n")
            fm_lines.append(f'intent_hash: "{new_hash}"')
            parts[1] = "\n" + "\n".join(fm_lines) + "\n"
            content = "---".join(parts)
    
    task_file.write_text(content, encoding="utf-8")


def write_state_hash_record(task_dir: Path, hash_record: dict) -> None:
    """Write hash record to 99_STATE.md."""
    state_file = task_dir / "99_STATE.md"
    
    state_content = f"""---
hash_record:
  intent_hash: "{hash_record['intent_hash']}"
  intent_hash_algo: {hash_record['intent_hash_algo']}
  intent_hash_scope: {hash_record['intent_hash_scope']}
  computed_at: "{hash_record['computed_at']}"
  hash_mismatch: {str(hash_record.get('hash_mismatch', False)).lower()}
---

# Derived State

This file is auto-generated by task scripts. Do not edit manually.

## Hash Record

- **Hash**: `{hash_record['intent_hash'][:16]}...`
- **Algorithm**: {hash_record['intent_hash_algo']}
- **Computed**: {hash_record['computed_at']}
- **Mismatch**: {hash_record.get('hash_mismatch', False)}
"""
    
    state_file.write_text(state_content, encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Compute and update intent hash for a task"
    )
    parser.add_argument(
        "--task",
        type=str,
        required=True,
        help="Path to task directory"
    )
    parser.add_argument(
        "--update",
        action="store_true",
        help="Update 00_TASK.md frontmatter with computed hash"
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check if stored hash matches computed hash"
    )
    parser.add_argument(
        "--state",
        action="store_true",
        help="Write hash record to 99_STATE.md"
    )
    parser.add_argument(
        "--json",
        action="store_true",
        help="Output as JSON"
    )

    args = parser.parse_args()
    task_dir = Path(args.task)

    if not task_dir.exists() or not task_dir.is_dir():
        print(f"Error: Invalid task directory: {task_dir}", file=sys.stderr)
        return 1

    try:
        canonical_blob = extract_canonical_intent(task_dir)
        computed_hash = compute_hash(canonical_blob)
        
        task_file = task_dir / "00_TASK.md"
        frontmatter, _, _ = read_frontmatter(task_file)
        stored_hash = frontmatter.get("intent_hash", "")
        
        if stored_hash.startswith("{{"):
            stored_hash = ""
        
        hash_mismatch = stored_hash != "" and stored_hash != computed_hash
        
        hash_record = {
            "intent_hash": computed_hash,
            "intent_hash_algo": "sha256-v1",
            "intent_hash_scope": "canonical-intent",
            "computed_at": get_utc_now_rfc3339(),
            "stored_hash": stored_hash if stored_hash else None,
            "hash_mismatch": hash_mismatch
        }
        
        if args.check:
            if hash_mismatch:
                print(f"MISMATCH: stored={stored_hash[:16]}... computed={computed_hash[:16]}...")
                return 1
            elif not stored_hash:
                print(f"NO_STORED_HASH: computed={computed_hash[:16]}...")
                return 2
            else:
                print(f"MATCH: {computed_hash[:16]}...")
                return 0
        
        if args.update:
            update_frontmatter_hash(task_file, computed_hash)
            hash_record["updated"] = True
        
        if args.state:
            write_state_hash_record(task_dir, hash_record)
            hash_record["state_written"] = True
        
        if args.json:
            print(json.dumps(hash_record, indent=2))
        else:
            print(computed_hash)
        
        return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
